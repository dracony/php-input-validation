<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>InputValidation for PHP by lastzero</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">InputValidation for PHP</h1>
      <h2 class="project-tagline">Easy &amp; secure whitelist validation for input data of any origin</h2>
      <a href="https://github.com/lastzero/php-input-validation" class="btn">View on GitHub</a>
      <a href="https://github.com/lastzero/php-input-validation/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/lastzero/php-input-validation/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>This library provides an <strong>abstract form class</strong> with built-in whitelist validation ("accept known good"). It uses <strong>language independent</strong> validation rules (plain array) that can be reused for client-side validation (JavaScript) or passed to template rendering engines such as Twig or Smarty (HTML). The library can be used with <strong>any framework</strong> and <strong>input source</strong> (HTML, REST, RPC, ...).</p>

<p>A major advantage of this modular approach is that developers can use <strong>unit testing</strong> to instantly find bugs and <strong>tune validation rules</strong> without an existing HTML frontend or storage backend. It's perfectly suited to build <strong>REST services</strong>. Use case specific input value validation is also more secure than general model validation, which often relies on a blacklist ("reject known bad").</p>

<p>Besides basic validation rules such as type or length, more advanced rules are supported as well - for example <strong>dependent fields</strong> and <strong>multi-page forms</strong>. Validated values can be fetched individually, as flat array, by tag or by page.</p>

<p>The architecture is <strong>simple by design</strong>: Form classes can inherit their definitions from each other. If needed, the validation behavior can be changed using standard object-oriented methodologies. You don't need to hold a PhD in design patterns to understand how it works. The code is <strong>mature</strong> and <strong>actively used</strong> in several commercial and Open Source projects.</p>

<h2>
<a id="validation" class="anchor" href="#validation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Validation</h2>

<p>This example shows how to validate user input in a REST controller action. Note how easy it is, to avoid the deeply nested structures you often find in validation code. User model and form are injected as dependencies. </p>

<pre><code>class UserController
{
    protected $user;
    protected $form;

    public function __construct(User $user, UserForm $form)
    {
        $this-&gt;user = $user;
        $this-&gt;form = $form;
    }

    public function putAction($id, Request $request) // Update
    {
        $this-&gt;user-&gt;find($id); // Find entity (throws exception, if not found)

        $this-&gt;form-&gt;setDefinedValues($this-&gt;user-&gt;getValues()); // Initialization
        $this-&gt;form-&gt;setDefinedWritableValues($request-&gt;request-&gt;all()); // Input values
        $this-&gt;form-&gt;validate(); // Validation

        if($this-&gt;form-&gt;hasErrors()) {
            // Return first error, since HTTP isn't designed to return multiple errors at once
            throw new FormInvalidException($this-&gt;form-&gt;getFirstError());
        }

        $this-&gt;user-&gt;update($this-&gt;form-&gt;getValues()); // Update values

        return $this-&gt;user-&gt;getValues(); // Return updated entity values
    }
}
</code></pre>

<h2>
<a id="definition" class="anchor" href="#definition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Definition</h2>

<pre><code>class UserForm extends \InputValidation\Form {
    protected function init(array $params = array())
    {
        $definition = array(
            'username': {
                type: 'string',
                caption: 'Username',
                required: true,
                min: 3,
                max: 15
            },
            'email': {
                type: 'email',
                caption: 'E-Mail',
                required: true
            },
            'gender': {
                type: 'string',
                caption: 'Gender',
                required: false,
                options: ['male', 'female'],
                optional: true
            },
            'birthday': {
                type: 'date',
                caption: 'Birthday',
                required: false
            },
            'password': {
                type: 'string',
                caption: 'Password',
                required: true,
                min: 5,
                max: 30
            },
            'password_again': {
                type: 'string',
                caption: 'Password confirmation',
                required: true,
                matches: 'password'
            },
            'continent': {
                type: 'string',
                caption: 'Region',
                required: true,
                options: ['north_america', 'south_america', 'europe', 'asia', 'australia']
            }
        );

        $this-&gt;setDefinition($definition);
    }
}
</code></pre>

<h2>
<a id="setup" class="anchor" href="#setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setup</h2>

<p>It is strongly recommended to use a <strong>dependency injection container</strong> such as the one provided by Symfony Components:</p>

<pre><code>services:
    message_selector:
        class: \Symfony\Component\Translation\MessageSelector

    yaml_loader:
        class: \Symfony\Component\Translation\Loader\YamlFileLoader

    array_loader:
        class: \Symfony\Component\Translation\Loader\ArrayLoader

    translator:
        class: \Symfony\Component\Translation\Translator
        arguments: ['de', @message_selector]
        calls:
          - [addLoader, ['yaml', @yaml_loader]]
          - [addLoader, ['array', @array_loader]]

    validator:
        class: \InputValidation\Validator

    form:
        class: \InputValidation\Form
        arguments: [@translator, @validator]
</code></pre>

<p>Alternativly, you can create new form instances manually (equivalent to the service definition above):</p>

<pre><code>use InputValidation\Form;
use InputValidation\Validator;
use Symfony\Component\Translation\Translator;
use Symfony\Component\Translation\MessageSelector;
use Symfony\Component\Translation\Loader\YamlFileLoader;
use Symfony\Component\Translation\Loader\ArrayLoader;

$translator = new Translator('en', new MessageSelector);
$translator-&gt;addLoader('yaml', new YamlFileLoader);
$translator-&gt;addLoader('array', new ArrayLoader);

$form = new Form($translator, new Validator());
</code></pre>

<p>Have a look at the unit tests in the Tests directory, so see more examples.</p>

<h2>
<a id="composer" class="anchor" href="#composer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composer</h2>

<p>If you are using composer, simply add "lastzero/php-input-validation" to your composer.json file to use this library:</p>

<pre><code>"require": {
    "lastzero/php-input-validation": "*"
}
</code></pre>

<h2>
<a id="form-validation-vs-model-validation" class="anchor" href="#form-validation-vs-model-validation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Form Validation vs Model Validation</h2>

<p>Model validation generally operates on <strong>trusted</strong> data (internal system state) and should be <strong>repeatable</strong> at any point in time while input validation explicitly operates <strong>once</strong> on data that comes from <strong>untrusted</strong> sources (depending on the use case and user privileges). This separation makes it possible to build reusable models, controllers and forms that can be coupled through dependency injection (see REST controller example at the top).</p>

<p>Think of input validation as <strong>whitelist</strong> validation ("accept known good") and model validation as <strong>blacklist</strong> validation ("reject known bad"). Whitelist validation is more secure while blacklist validation prevents your model layer from being overly constraint to very specific use cases.</p>

<p>Invalid model data should always cause an <strong>exception</strong> to be thrown (otherwise the application can continue running without noticing the mistake) while invalid input values coming from external sources are <strong>not unexpected</strong>, but rather common (unless you got users that never make mistakes). Validation within a specific model may not be possible at all, if a set of input values must be validated together (because they depend on each other) but individual values are then stored in different models - at least it can create <strong>additional dependencies</strong> between models that would not be there otherwise up to the point that all models depend on each other. In short: The application may still work as expected, but the code is a mess.</p>

<p>From a theoretical standpoint, any complex system has more <strong>internal state</strong> than it exposes to the outside, thus it is never sufficient to use model validation only - except the model provides two sets of methods: some that are used internally and some that can be exposed to arbitrary input data from any source. Aside from side-effects such as limited user feedback (exception messages) and bloated model code, this approach may easily lead to serious security flaws. Malicious input data is a much higher threat to <strong>multi-user</strong> Web applications than to classical <strong>single-user</strong> desktop applications. Simple blacklist model validation may be fully sufficient for desktop applications, which are in full control of the user interface (view layer).</p>

<p>Client-side (JavaScript or HTML) form validation is always just a convenience feature and <strong>not reliable</strong>. However, with this library you can (at least partly) <strong>reuse existing server-side form validation</strong> rules to perform client-side validation, since they can be easily converted to JSON (for JavaScript) or be passed to template rendering engines such as Twig or Smarty (for HTML). Reusing model layer validation rules in a similar fashion is at least difficult, if not impossible.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/lastzero/php-input-validation">InputValidation for PHP</a> is maintained by <a href="https://github.com/lastzero">lastzero</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
